/*
 * output.cpp
 *
 *  Created on: 16 Mar 2016
 *      Author: ladislav
 */

#include "output.h"

void writeDataFile(string strFilename, vector<double> &vdData)
{
	std::ofstream OutputStream(strFilename.c_str());

	for (unsigned int nRow = 0; nRow < vdData.size(); ++nRow)
	{
		OutputStream << vdData.at(nRow) << "\n";
	}
}

void writeDataFile(string strFilename, vector2d &vvdData) 
{
	std::ofstream OutputStream(strFilename.c_str());

	for (unsigned int nRow = 0; nRow < vvdData.size(); ++nRow)
	{
		for (unsigned int nColumn = 0; nColumn < vvdData.at(nRow).size(); ++nColumn)
		{
			OutputStream << vvdData.at(nRow).at(nColumn) << " ";
		}

		OutputStream << "\n";
	}
}

void backupFile(string strFilename) 
{
	fs::path Path = strFilename;

	if (fs::exists(Path))
	{
		int nBackup = 0;
		fs::path PathNew;
		do
		{
			std::stringstream Stream;
			Stream << "bck." << nBackup << "." << strFilename;
			PathNew = Stream.str();
			++nBackup;
		}
		while (fs::exists(PathNew));

		std::cout << "Backing up file " << Path << " to " << PathNew << std::endl;
		fs::rename(Path, PathNew);
	}
}

void createColvarFile(vector2d &vvdNewColvarsPath, vector<int> &vnSnapshots, int nPrecision, string strFilename)
{
	std::cout << "Creating a new COLVAR file called: " << strFilename << std::endl;
	backupFile(strFilename);

	std::ofstream OutputStream(strFilename.c_str());
	OutputStream.precision(nPrecision - 1);
	OutputStream << std::scientific;

	for (unsigned int nSnapshot = 0; nSnapshot < vnSnapshots.size(); ++nSnapshot)
	{
		OutputStream << nSnapshot + 1 << " ";

		int nRow = vnSnapshots[nSnapshot];
		for (unsigned int nColumn = 0; nColumn < vvdNewColvarsPath[nRow].size(); ++nColumn)
			OutputStream << vvdNewColvarsPath[nRow][nColumn] << " ";
		OutputStream << "\n";
	}
}

void createPlumedFile(Solution &sBest, vector2d &vvdLimits, InputData &sInput, string strFilename)
{
	std::cout << "Creating a new Plumed file called: " << strFilename << std::endl;
	backupFile(strFilename);

	std::ofstream OutputStream(strFilename.c_str());
	OutputStream.precision(sInput.nPrecision - 1);
	OutputStream << std::scientific;

	OutputStream << "# Plumed file generated by the COMet script\n\n";
	if (!sInput.bNoPath)
		OutputStream << "LOAD FILE=FuncPathGeneral.cpp\n\n";
	OutputStream << "# The file containing the CV definitions\n";
	OutputStream << "INCLUDE FILE=cv_definitions.dat\n";

	vector<double> vdGradients;
	if (!vvdLimits.empty())
	{
		for (int nCV = 0; nCV < sBest.vdCoefficients.size(); ++nCV)
		{
			double dGradient = 1.0 / (vvdLimits[1][nCV] - vvdLimits[0][nCV]);
			vdGradients.push_back(dGradient);
		}
	}

	if (!vvdLimits.empty() && !sInput.bDescale)
	{
		OutputStream << "\n";
		for (int nCV = 0; nCV < sBest.vdCoefficients.size(); ++nCV)
		{
			double dConstant = -vvdLimits[0][nCV] * vdGradients[nCV];

			OutputStream << "const" << nCV << ": CONSTANT VALUE=" << dConstant << "\n";
			OutputStream << "resc_cv" << nCV << ": COMBINE ARG=cv" << nCV << ",const" << nCV <<
				" COEFFICIENTS=" << vdGradients[nCV] << ",1 PERIODIC=NO\n";
		}
	}
	
	vector<double> vdPeriodics;

	if (sInput.bConvertPeriodic)
	{
		OutputStream << "\n";
		for (unsigned int nColumn = 0; nColumn < sInput.vnNewColumnsPath.size(); ++nColumn)
		{
			int nPeriodic = -1;
			for (unsigned int nCount = 0; nCount < sInput.vnPeriodicColumnsPath.size(); ++nCount)
				if (nColumn == sInput.vnPeriodicColumnsPath[nCount])
					nPeriodic = nCount;

			if (nPeriodic < 0)
				vdPeriodics.push_back(-1.0);
			else
				vdPeriodics.push_back(sInput.vdPeriodicRanges[nPeriodic]);
		}

		int nCoeff = 0;
		for (unsigned int nCV = 0; nCV < sInput.vnNewColumnsPath.size(); ++nCV)
		{
			if (vdPeriodics[nCV] > 0.0)
			{
				OutputStream << "conv_cv" << nCV << ": MATHEVAL ARG=";
				OutputStream << ((vvdLimits.empty() || sInput.bDescale) ? "cv" : "resc_cv");
				OutputStream << nCV << " FUNC=0.5+cos(2*pi*(x";
				if (sBest.vdPeriodicCoeffs[nCoeff] < 0.0)
				{
					OutputStream << "+";
					if (!vvdLimits.empty() && sInput.bDescale)
						OutputStream << -sBest.vdPeriodicCoeffs[nCoeff] / vdGradients[nCV];
					else
						OutputStream << -sBest.vdPeriodicCoeffs[nCoeff];
				}
				else
				{
					OutputStream << "-";
					if (!vvdLimits.empty() && sInput.bDescale)
						OutputStream << sBest.vdPeriodicCoeffs[nCoeff] / vdGradients[nCV];
					else
						OutputStream << sBest.vdPeriodicCoeffs[nCoeff];
				}
				OutputStream << ")/" << vdPeriodics[nCV] << ") PERIODIC=NO\n";
				++nCoeff;
			}
		}
	}

	OutputStream << ((sInput.bNoPath) ? "\ncomb_cv: COMBINE ARG=" : "\npath: FUNCPATHGENERAL ARG=");
	for (int nCV = 0; nCV < sBest.vdCoefficients.size(); ++nCV)
	{
		if (!vdPeriodics.empty() && vdPeriodics[nCV] > 0.0)
			OutputStream << "conv_cv";
		else if (vvdLimits.empty() || sInput.bDescale)
			OutputStream << "cv";
		else
			OutputStream << "resc_cv";
		OutputStream << nCV;
		if (nCV != sBest.vdCoefficients.size() - 1)
			OutputStream << ",";
	}
	OutputStream << " COEFFICIENTS=";
	for (int nCV = 0; nCV < sBest.vdCoefficients.size(); ++nCV)
	{
		if (!vvdLimits.empty() && sInput.bDescale)
			OutputStream << sBest.vdCoefficients[nCV] * vdGradients[nCV];
		else
			OutputStream << sBest.vdCoefficients[nCV];
		if (nCV != sBest.vdCoefficients.size() - 1)
			OutputStream << ",";
	}
	if (sInput.bNoPath)
		OutputStream << " PERIODIC=NO";
	else
		OutputStream << " REFERENCE=COLVAR_PATH LAMBDA=" << sBest.dLambda; 
	OutputStream << "\n\n";

	OutputStream << "PRINT ARG=" << ((sInput.bNoPath) ? "comb_cv" : "path.s,path.z") <<
		" STRIDE=1 FILE=COLVAR_TEST FMT=%8.4f";
}
